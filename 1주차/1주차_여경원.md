# Chapter 1: 디자인 패턴과 프로그래밍 패러다임 - 면접 대비 요약

## 목차

### Section 1: 디자인 패턴

1. [싱글톤 패턴](#1-싱글톤-패턴-singleton-pattern)
2. [팩토리 패턴](#2-팩토리-패턴-factory-pattern)
3. [전략 패턴](#3-전략-패턴-strategy-pattern)
4. [옵저버 패턴](#4-옵저버-패턴-observer-pattern)
5. [프록시 패턴과 프록시 서버](#5-프록시-패턴과-프록시-서버)
6. [이터레이터 패턴](#6-이터레이터-패턴-iterator-pattern)
7. [노출모듈 패턴](#7-노출모듈-패턴-revealing-module-pattern)
8. [MVC 패턴](#8-mvc-패턴)
9. [MVP 패턴](#9-mvp-패턴)
10. [MVVM 패턴](#10-mvvm-패턴)

### Section 2: 프로그래밍 패러다임

1. [선언형과 함수형 프로그래밍](#1-선언형과-함수형-프로그래밍)
2. [객체지향 프로그래밍](#2-객체지향-프로그래밍)
3. [절차형 프로그래밍](#3-절차형-프로그래밍)
4. [패러다임의 혼합](#4-패러다임의-혼합)

---

## Section 1: 디자인 패턴

### 디자인 패턴 개념

- **정의**: 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것
- **면접 출제 포인트**: 디자인 패턴은 면접에서 매우 자주 출제되는 주제이며, 특히 각 패턴의 정의, 사용 시기, 장단점, 실제 사용 사례를 명확히 설명할 수 있어야 함

---

## 1. 싱글톤 패턴 (Singleton Pattern)

### 기본 개념
- 하나의 클래스에 **오직 하나의 인스턴스**만 가지는 패턴
- 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는 데 사용
- 보통 **데이터베이스 연결 모듈**에 많이 사용

### 장단점 분석

#### 장점
- 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 **인스턴스를 생성할 때 드는 비용이 줄어듦**

#### 단점
- **의존성이 높아짐**
- **TDD(Test Driven Development)를 할 때 걸림돌**이 됨
  - 단위 테스트는 테스트가 서로 독립적이어야 함
  - 테스트를 어떤 순서로든 실행할 수 있어야 함
  - 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 '독립적인' 인스턴스를 만들기가 어려움

### 실제 사용 사례

#### mongoose의 싱글톤 패턴
- Node.js에서 MongoDB 데이터베이스를 연결할 때 쓰는 mongoose 모듈에서 볼 수 있음
- mongoose의 데이터베이스를 연결할 때 쓰는 `connect()` 함수는 싱글톤 인스턴스를 반환

#### MySQL의 싱글톤 패턴
- Node.js에서 MySQL 데이터베이스를 연결할 때도 싱글톤 패턴이 사용됨
- 메인 모듈에서 데이터베이스 연결에 관한 인스턴스를 정의하고 다른 모듈에서 해당 인스턴스를 기반으로 쿼리를 보내는 형식으로 사용

### 의존성 주입 (Dependency Injection)

#### 개념 및 필요성
- 싱글톤 패턴은 사용하기가 쉽고 굉장히 실용적이지만 **모듈 간의 결합을 강하게 만들 수 있다는 단점**이 있음
- 의존성 주입을 통해 모듈 간의 결합을 조금 더 느슨하게 만들어 해결 가능
- **의존성(종속성)**: A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 또한 변해야 된다는 것을 의미

#### 작동 방식
- 메인 모듈이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 **의존성 주입자**가 이 부분을 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식

#### 장점
- 모듈들을 쉽게 교체할 수 있는 구조가 되어 **테스팅하기 쉽고 마이그레이션하기도 수월**
- 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에:
  - 애플리케이션 의존성 방향이 일관됨
  - 애플리케이션을 쉽게 추론할 수 있음
  - 모듈 간의 관계들이 조금 더 명확해짐

#### 단점
- 모듈들이 더욱더 분리되므로 **클래스 수가 늘어나 복잡성이 증가**할 수 있음
- 약간의 **런타임 페널티**가 생기기도 함

#### 의존성 주입 원칙
> "상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 합니다. 또한, 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 합니다."

**면접 출제 포인트**: 싱글톤 패턴의 단점을 극복하는 방법으로 의존성 주입이 자주 언급됨. 실제 프로젝트에서 어떤 방식으로 의존성 주입을 구현했는지, Spring의 DI 컨테이너 등 프레임워크 레벨에서의 구현 방식도 함께 알아두어야 함

---

## 2. 팩토리 패턴 (Factory Pattern)

### 기본 개념
- **객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴**
- 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

### 장점 분석
- **상위 클래스와 하위 클래스가 분리**되기 때문에 느슨한 결합을 가짐
- 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 **더 많은 유연성**을 갖게 됨
- 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되니 **유지 보수성이 증가**됨

### 실제 구현 예시
라떼 레시피와 아메리카노 레시피, 우유 레시피라는 구체적인 내용이 들어 있는 하위 클래스가 컨베이어 벨트를 통해 전달되고, 상위 클래스인 바리스타 공장에서 이 레시피들을 토대로 우유 등을 생산하는 생산 공정

#### JavaScript에서의 구현
- JavaScript에서는 `new Object()`로 간단하게 구현 가능
- 숫자를 전달하거나 문자열을 전달함에 따라 다른 타입의 객체를 생성
- 전달받은 값에 따라 다른 객체를 생성하며 인스턴스의 타입 등을 정함

#### Java에서의 구현
- 문자열 비교 기반으로 로직이 구성
- Enum 또는 Map을 이용하여 if문을 쓰지 않고 매핑해서 구현 가능

**면접 출제 포인트**: 팩토리 패턴과 추상 팩토리 패턴의 차이점, 빌더 패턴과의 차이점을 명확히 구분할 수 있어야 함. 실제로 어떤 상황에서 팩토리 패턴을 사용하는 것이 적절한지에 대한 판단 기준도 중요함

---

## 3. 전략 패턴 (Strategy Pattern)

### 기본 개념
- **정책 패턴**이라고도 함
- 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 **'캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴**

### 실생활 예시
우리가 어떤 것을 살 때 네이버페이, 카카오페이 등 다양한 방법으로 결제하듯이 어떤 아이템을 살 때 결제 방식의 '전략'만 바꿔서 두 가지 방식으로 결제하는 것을 구현

### 실제 사용 사례: passport의 전략 패턴

#### passport 라이브러리
- Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리
- 여러 가지 '전략'을 기반으로 인증할 수 있게 함
- **LocalStrategy 전략**: 서비스 내의 회원가입된 아이디와 비밀번호를 기반으로 인증
- **OAuth 전략**: 페이스북, 네이버 등 다른 서비스를 기반으로 인증

#### 구현 방식
- `passport.use()`라는 메서드에 '전략'을 매개변수로 넣어서 로직을 수행

### 용어 정리
- **컨텍스트**: 프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말함

**면접 출제 포인트**: 전략 패턴과 상태 패턴의 차이점을 구분할 수 있어야 함. 실제 프로젝트에서 전략 패턴을 어떤 방식으로 적용했는지, 특히 결제 시스템이나 인증 시스템에서의 활용 경험을 설명할 수 있어야 함

---

## 4. 옵저버 패턴 (Observer Pattern)

### 기본 개념
- **주체가 어떤 객체의 상태 변화를 관찰**하다가 상태 변화가 있을 때마다 메서드 등을 통해 **옵저버 목록에 있는 옵저버들에게 변화를 알려주는** 디자인 패턴

### 주체와 옵저버의 관계
- **주체**: 객체의 상태 변화를 보고 있는 관찰자
- **옵저버들**: 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들

### 구조 형태
- 옵저버 패턴은 주체와 객체를 따로 두거나, 상태가 변경되는 객체를 기반으로 구축하기도 함

### 실제 활용 사례

#### 트위터의 옵저버 패턴
내가 어떤 사람인 주체를 '팔로우'했다면 주체가 포스팅을 올리게 되면 알림이 '팔로워'에게 가는 시스템이 옵저버 패턴의 대표적인 예시

#### MVC 패턴에서의 활용
- 옵저버 패턴은 주로 **이벤트 기반 시스템**에 사용
- **MVC(Model-View-Controller) 패턴**에도 사용됨
- 주체라고 볼 수 있는 모델에서 변경 사항이 생겨 `update()` 메서드로 옵저버인 뷰에 알려주고 이를 기반으로 컨트롤러 등이 작동하는 방식

### JavaScript에서의 구현: 프록시 객체

#### 프록시 객체의 개념
- **어떠한 대상의 기본적인 동작**(속성 접근, 할당, 순회, 열거, 함수 호출 등)**의 작업을 가로챌 수 있는 객체**

#### 매개변수
- **target**: 프록시할 대상
- **handler**: 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수

#### 주요 함수들
- **get() 함수**: 속성과 함수에 대한 접근을 가로챔
- **has() 함수**: in 연산자의 사용을 가로챔
- **set() 함수**: 속성에 대한 접근을 가로챔

### Vue.js 3.0의 옵저버 패턴
- 프런트엔드에서 많이 쓰는 프레임워크 Vue.js 3.0에서 `ref`나 `reactive`로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경됨
- 이는 **프록시 객체를 이용한 옵저버 패턴을 이용하여 구현**한 것

**면접 출제 포인트**: 옵저버 패턴과 발행-구독 패턴의 차이점, 실제 프론트엔드 프레임워크에서의 구현 방식, 성능상의 고려사항 등을 설명할 수 있어야 함. 특히 Vue.js나 React의 상태 관리와 연관지어 설명할 수 있으면 좋음

---

## 5. 프록시 패턴과 프록시 서버

### 프록시 패턴의 개념
- **대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는** 디자인 패턴
- 이를 통해 객체의 속성, 변환 등을 보완하며 **보안, 데이터 검증, 캐싱, 로깅**에 사용

### 프록시 서버의 개념
- **서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는** 컴퓨터 시스템이나 응용 프로그램

### nginx를 프록시 서버로 활용

#### nginx의 특징
- **비동기 이벤트 기반의 구조**와 다수의 연결을 효과적으로 처리 가능한 웹 서버
- 주로 Node.js 서버 앞단의 프록시 서버로 활용됨

#### Node.js 창시자의 권고사항
라이언 달(Ryan Dahl)은 "Node.js의 버퍼 오버플로우 취약점을 예방하기 위해서는 nginx를 프록시 서버로 앞단에 놓고 Node.js를 뒤쪽에 놓는 것이 좋다"고 권장

#### nginx 사용의 장점
- **익명 사용자의 직접적인 서버로의 접근을 차단**하고 간접적으로 한 단계를 더 거침으로써 보안성을 더욱 강화 가능
- **실제 포트를 숨길 수 있음**
- **정적 자원을 gzip 압축**할 수 있음
- **메인 서버 앞단에서의 로깅**을 할 수도 있음

### CloudFlare를 프록시 서버로 활용

#### CloudFlare의 기능
- **전 세계적으로 분산된 서버**가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 **CDN 서비스**
- 웹 서버 앞단에 두어 '프록시 서버'로 사용

#### 주요 이점

##### DDOS 공격 방어
- **DDOS**: 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형
- CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단해서 DDOS 공격으로부터 보호

##### HTTPS 구축
- 서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수도 있지만, CloudFlare를 사용하면 **별도의 인증서 설치 없이 좀 더 손쉽게 HTTPS를 구축** 가능

### CORS와 프런트엔드의 프록시 서버

#### CORS의 개념
- **CORS(Cross-Origin Resource Sharing)**: 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘

#### 프론트엔드 개발 시의 문제
- 프런트엔드 개발 시 프런트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 **CORS 에러**를 마주침
- 이를 해결하기 위해 프런트엔드에서 프록시 서버를 만들기도 함

#### 해결 방안
예를 들어 프런트엔드에서는 `127.0.0.1:3000`으로 테스팅을 하는데 백엔드 서버는 `127.0.0.1:12010`이라면 포트 번호가 다르기 때문에 CORS 에러가 나타남. 이때 **프록시 서버를 둬서 프런트엔드 서버에서 요청되는 오리진을 `127.0.0.1:12010`으로 바꾸는 것**

### 용어 정리

- **오리진**: 프로토콜과 호스트 이름, 포트의 조합. 예를 들어 `https://kundol.com:12010/test`라는 주소에서 오리진은 `https://kundol.com:12010`을 뜻함
- **버퍼 오버플로우**: 버퍼는 보통 데이터가 저장되는 메모리 공간으로, 메모리 공간을 벗어나는 경우를 말함. 이때 사용되지 않아야 할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이 발생하기도 함
- **gzip 압축**: LZ77과 Huffman 코딩의 조합인 DEFLATE 알고리즘을 기반으로 한 압축 기술. gzip 압축을 하면 데이터 전송량을 줄일 수 있지만, 압축을 해제했을 때 서버에서의 CPU 오버헤드도 생각해서 gzip 압축 사용 유무를 결정해야 함
- **CDN(Content Delivery Network)**: 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크

**면접 출제 포인트**: 프록시 서버의 다양한 활용 사례와 각각의 장단점을 비교 설명할 수 있어야 함. 실제 운영 환경에서의 아키텍처 설계 경험, 로드 밸런싱과의 차이점 등도 중요한 질문 포인트

---

## 6. 이터레이터 패턴 (Iterator Pattern)

### 기본 개념
- **이터레이터를 사용하여 컬렉션의 요소들에 접근하는** 디자인 패턴
- 이를 통해 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 **이터레이터라는 하나의 인터페이스로 순회가 가능**

### JavaScript에서의 구현
- JavaScript에서는 분명히 다른 자료 구조인 Set과 Map임에도 똑같은 `for...of`라는 **이터레이터 프로토콜을 통해 순회**하는 것을 볼 수 있음

### 용어 정리
- **이터레이터 프로토콜**: 이터러블한 객체들을 순회할 때 쓰이는 규칙
- **이터러블한 객체**: 반복 가능한 객체로 배열을 일반화한 객체

**면접 출제 포인트**: 다양한 컬렉션 타입을 동일한 방식으로 순회할 수 있게 하는 이터레이터 패턴의 장점과 실제 언어별 구현 방식의 차이점을 설명할 수 있어야 함

---

## 7. 노출모듈 패턴 (Revealing Module Pattern)

### 기본 개념
- **즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴**
- JavaScript는 private나 public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행되기 때문에, **노출모듈 패턴을 통해 private와 public 접근 제어자를 구현**하기도 함

### 구현 방식
- 즉시 실행 함수 내부에서 변수와 함수를 선언
- public으로 노출하고 싶은 부분만 return 객체에 포함시키는 방식으로 구현
- 이를 통해 **private 범위와 public 범위를 구분** 가능

### 관련 모듈 시스템
- 노출모듈 패턴을 기반으로 만든 JavaScript 모듈 방식으로는 **CJS(CommonJS) 모듈 방식**이 있음

### 용어 정리

- **public**: 클래스에 정의된 함수에서 접근 가능하며 자식 클래스와 외부 클래스에서 접근 가능한 범위
- **protected**: 클래스에 정의된 함수에서 접근 가능, 자식 클래스에서 접근 가능하지만 외부 클래스에서 접근 불가능한 범위
- **private**: 클래스에 정의된 함수에서 접근 가능하지만 자식 클래스와 외부 클래스에서 접근 불가능한 범위
- **즉시 실행 함수**: 함수를 정의하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용

**면접 출제 포인트**: JavaScript의 모듈 시스템 발전 과정과 각각의 장단점, ES6 모듈과 CommonJS 모듈의 차이점을 연결지어 설명할 수 있어야 함

---

## 8. MVC 패턴

### 기본 개념
- **모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진** 디자인 패턴
- 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 **개발 프로세스에서 각각의 구성 요소에만 집중해서 개발** 가능

### 장단점 분석

#### 장점
- **재사용성과 확장성이 용이**함
- **각 구성 요소에만 집중해서 개발**할 수 있어 개발 효율성이 높음

#### 단점
- **애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점**이 있음

### 구성 요소 상세 분석

#### 모델 (Model)
- **애플리케이션의 데이터**인 데이터베이스, 상수, 변수 등을 뜻함
- 사각형 모양의 박스 안에 글자가 들어 있다면 그 사각형 모양의 박스 위치 정보, 글자 내용, 글자 위치, 글자 포맷(utf-8 등)에 관한 정보를 모두 가지고 있어야 함
- **뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신**함

#### 뷰 (View)
- **inputbox, checkbox, textarea 등 사용자 인터페이스 요소**를 나타냄
- **모델을 기반으로 사용자가 볼 수 있는 화면**을 뜻함
- **모델이 가지고 있는 정보를 따로 저장하지 않아야 하며** 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고 있어야 함
- **변경이 일어나면 컨트롤러에 이를 전달**해야 함

#### 컨트롤러 (Controller)
- **하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할**을 하며 이벤트 등 메인 로직을 담당
- **모델과 뷰의 생명주기도 관리**
- **모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줌**

### MVC 패턴의 예: React.js

#### React.js의 특징
- **유저 인터페이스를 구축하기 위한 라이브러리**
- **'가상 DOM'을 통해 실제 DOM을 조작하는 것을 추상화해서 성능을 높임**

#### 주요 특성
- **불변성(immutable)**: state는 setState를 통해서만 수정이 가능하고, props를 기반으로 해서 만들어지는 컴포넌트인 pureComponent가 있음
- **단방향 바인딩**: 데이터 흐름이 한 방향으로만 흐름
- **높은 자유도**: 개발자가 원하는 방식으로 구조를 설계할 수 있음
- **대기업 운영**: 메타(페이스북)가 운영하고 있으며 넷플릭스, 트위터, 드롭박스, 우버, 페이팔, 마이크로소프트 등에서 사용됨

**면접 출제 포인트**: MVC 패턴과 MVP, MVVM 패턴의 차이점을 명확히 구분할 수 있어야 함. 실제 프레임워크에서 MVC 패턴이 어떻게 구현되었는지, 특히 React.js가 순수한 MVC 패턴인지에 대한 논의도 중요함

---

## 9. MVP 패턴

### 기본 개념
- **MVC 패턴으로부터 파생**되었으며 MVC에서 C에 해당하는 컨트롤러가 **프레젠터(presenter)로 교체된 패턴**

### MVC 패턴과의 차이점

#### 관계성
- **뷰와 프레젠터는 일대일 관계**이기 때문에 MVC 패턴보다 **더 강한 결합을 지닌** 디자인 패턴

#### 의존성
- **MVC**에서는 뷰가 모델을 직접 참조할 수 있음
- **MVP**에서는 뷰가 모델을 직접 참조하지 않고 **프레젠터를 통해서만 데이터에 접근**

**면접 출제 포인트**: MVP 패턴이 MVC 패턴의 어떤 문제점을 해결하려고 했는지, 실제 안드로이드 개발 등에서 어떻게 활용되는지 설명할 수 있어야 함

---

## 10. MVVM 패턴

### 기본 개념
- **MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴**
- 여기서 **뷰모델은 뷰를 더 추상화한 계층**

### 주요 특징
- **커맨드와 데이터 바인딩**: MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징
- **양방향 데이터 바인딩**: 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원
- **재사용성**: UI를 별도의 코드 수정 없이 재사용할 수 있음
- **테스트 용이성**: 단위 테스팅하기 쉽다는 장점이 있음

### MVVM 패턴의 예: Vue.js

#### Vue.js의 특징
- **반응형(reactivity)이 특징**인 프런트엔드 프레임워크
- **watch와 computed 등으로 쉽게 반응형적인 값들을 구축** 가능
- **함수를 사용하지 않고 값 대입만으로도 변수가 변경**됨
- **양방향 바인딩을 지원**
- **HTML을 토대로 컴포넌트를 구축** 가능
- **재사용 가능한 컴포넌트 기반으로 UI를 구축** 가능
- BMW, 구글, 루이비통 등에서 사용

### 용어 정리
- **커맨드**: 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
- **데이터 바인딩**: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경됨

**면접 출제 포인트**: MVVM 패턴의 데이터 바인딩 메커니즘, 실제 Vue.js나 Angular에서의 구현 방식, 성능 최적화 방법 등을 설명할 수 있어야 함

---

## Section 2: 프로그래밍 패러다임

### 프로그래밍 패러다임 개념
- 프로그래밍 패러다임은 **프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론**
- 예를 들어:
  - **객체지향 프로그래밍**: 프로그래머들이 프로그램을 상호 작용하는 객체들의 집합으로 볼 수 있게 함
  - **함수형 프로그래밍**: 상태 값을 지니지 않는 함수 값들의 연속으로 생각할 수 있게 해줌

### 언어별 패러다임 지원

#### 단일 패러다임
- **jdk 1.8 이전의 자바**: 객체지향 프로그래밍을 지원
- **하스켈**: 함수형 프로그래밍을 지원

#### 다중 패러다임
- **C++, 파이썬, 자바스크립트**: 여러 패러다임을 지원

#### 자바의 발전
- **jdk 1.8부터** 함수형 프로그래밍 패러다임을 지원하기 위해:
  - 람다식
  - 생성자 레퍼런스
  - 메서드 레퍼런스를 도입
- 선언형 프로그래밍을 위해 **스트림 같은 표준 API** 등도 추가

### 패러다임 분류
- 프로그래밍 패러다임은 크게 **선언형, 명령형**으로 나뉨
- **선언형**은 함수형이라는 하위 집합을 가짐
- **명령형**은 다시 객체지향, 절차지향으로 나뉨

**면접 출제 포인트**: 각 패러다임의 특징과 장단점, 실제 프로젝트에서 어떤 패러다임을 선택했는지와 그 이유를 설명할 수 있어야 함

---

## 1. 선언형과 함수형 프로그래밍

### 선언형 프로그래밍의 개념
- **'무엇을' 풀어내는가에 집중하는 패러다임**
- **"프로그램은 함수로 이루어진 것이다."**라는 명제가 담겨 있는 패러다임
- **함수형 프로그래밍은 선언형 패러다임의 일종**

### 함수형 프로그래밍의 특징
- 작은 **'순수 함수'들을 블록처럼 쌓아 로직을 구현**하고 **'고차 함수'를 통해 재사용성을 높인** 프로그래밍 패러다임
- 자바스크립트는 단순하고 유연한 언어이며, **함수가 일급 객체**이기 때문에 객체지향 프로그래밍보다는 **함수형 프로그래밍 방식이 선호**됨

### 핵심 개념들

#### 순수 함수
- **출력이 입력에만 의존**하는 것을 의미
- **들어오는 매개변수에만 영향**을 받음
- 다른 전역 변수 등이 출력에 영향을 주면 순수 함수가 아님

#### 고차 함수
- **함수가 함수를 값처럼 매개변수로 받아 로직을 생성**할 수 있는 것

### 일급 객체의 특징
고차 함수를 쓰기 위해서는 해당 언어가 **일급 객체**라는 특징을 가져야 함:

- **변수나 메서드에 함수를 할당**할 수 있음
- **함수 안에 함수를 매개변수로 담을** 수 있음
- **함수가 함수를 반환**할 수 있음

### 추가 특징
- 함수형 프로그래밍은 이외에도 **커링, 불변성** 등 많은 특징이 있음

**면접 출제 포인트**: 순수 함수와 부작용(side effect)의 개념, 불변성의 중요성, 실제 프로젝트에서 함수형 프로그래밍을 어떻게 적용했는지 설명할 수 있어야 함. JavaScript의 map, filter, reduce 같은 고차 함수 활용 경험도 중요함

---

## 2. 객체지향 프로그래밍

### 기본 개념
- **객체지향 프로그래밍(OOP, Object-Oriented Programming)**은 **객체들의 집합으로 프로그램의 상호 작용을 표현**하며 **데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용**하는 방식

### 장단점 분석

#### 단점
- **설계에 많은 시간이 소요**됨
- **처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림**

### 객체지향 프로그래밍의 4가지 특징

#### 추상화 (Abstraction)
- **복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것**
- **예시**: 사람의 특징 중에서 프로그램에 필요한 특징만 뽑아내어 나타내는 것

#### 캡슐화 (Encapsulation)
- **객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것**
- **정보 은닉과 접근 제어를 통해 객체의 무결성을 보장**

#### 상속성 (Inheritance)
- **상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것**
- **코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요**

#### 다형성 (Polymorphism)
- **하나의 메서드나 클래스가 다양한 방법으로 동작하는 것**
- 대표적으로 **오버로딩, 오버라이딩**이 있음

### 다형성의 세부 분류

#### 오버로딩 (Overloading)
- **같은 이름을 가진 메서드를 여러 개 두는 것**
- **메서드의 타입, 매개변수의 유형, 개수** 등으로 여러 개를 둘 수 있음
- **컴파일 중에 발생하는 '정적' 다형성**

#### 오버라이딩 (Overriding)
- 주로 **메서드 오버라이딩**을 말하며 **상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의**하는 것
- **런타임 중에 발생하는 '동적' 다형성**

### 설계 원칙: SOLID 원칙

#### 단일 책임 원칙 (SRP, Single Responsibility Principle)
- **모든 클래스는 각각 하나의 책임만 가져야 하는 원칙**

#### 개방-폐쇄 원칙 (OCP, Open Closed Principle)
- **유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 하는 원칙**
- **기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게** 할 수 있어야 함

#### 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
- **프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것**
- **부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가게** 만드는 것

#### 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
- **하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙**

#### 의존 역전 원칙 (DIP, Dependency Inversion Principle)
- **자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙**
- **상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립**해야 함

**면접 출제 포인트**: SOLID 원칙을 실제 코드 설계에 어떻게 적용했는지, 각 원칙을 위반했을 때 발생할 수 있는 문제점들, 리팩토링 경험 등을 구체적으로 설명할 수 있어야 함

---

## 3. 절차형 프로그래밍

### 기본 개념
- **로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있음**
- **일이 진행되는 방식으로 그저 코드를 구현**하기만 하면 되기 때문에 **코드의 가독성이 좋으며 실행 속도가 빠름**

### 장단점 분석

#### 장점
- **코드의 가독성이 좋음**
- **실행 속도가 빠름**
- **계산이 많은 작업 등에 적합**

#### 단점
- **모듈화하기가 어려움**
- **유지 보수성이 떨어짐**

### 활용 사례
- **포트란(fortran)을 이용한 대기 과학 관련 연산 작업**
- **머신 러닝의 배치 작업**
- **수치 계산이나 시뮬레이션 등 성능이 중요한 분야**

**면접 출제 포인트**: 어떤 상황에서 절차형 프로그래밍이 더 적합한지, 객체지향과 절차형의 성능 차이가 발생하는 이유를 설명할 수 있어야 함

---

## 4. 패러다임의 혼합

### 최적의 패러다임 선택
- 어떠한 패러다임이 가장 좋을까에 대한 답은 **"그런 것은 없다"**
- **비즈니스 로직이나 서비스의 특징을 고려해서 패러다임을 정하는 것이 좋음**

### 혼합 사용의 장점
- 하나의 패러다임을 기반으로 통일하여 서비스를 구축하는 것도 좋지만
- **여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발**하는 것이 좋음

### 실제 적용 예시
예를 들어 백엔드에 머신 러닝 파이프라인과 거래 관련 로직이 있다면:

- **머신 러닝 파이프라인**: 절차지향형 패러다임 (성능이 중요)
- **거래 관련 로직**: 함수형 프로그래밍 (불변성과 안전성이 중요)

### 현대 개발의 트렌드
- 현대의 많은 프로그래밍 언어와 프레임워크들이 **다중 패러다임을 지원하는 이유**도 이러한 유연성 때문
- 개발자는 **각 상황에 맞는 최적의 패러다임을 선택하여 더 효율적이고 유지보수하기 좋은 코드**를 작성할 수 있음

**면접 출제 포인트**: 실제 프로젝트에서 어떤 기준으로 패러다임을 선택했는지, 여러 패러다임을 혼합 사용할 때 발생할 수 있는 문제점과 해결 방법을 설명할 수 있어야 함

---
## 예상 면접 질문

### 디자인 패턴 관련

**Q: 옵저버 패턴을 어떻게 구현하나요?**

A: 여러 가지 방법이 있지만 프록시 객체를 써서 하곤 합니다. 프록시 객체를 통해 객체의 속성이나 메서드 변화 등을 감지하고 이를 미리 설정해 놓은 옵저버들에게 전달하는 방법으로 구현합니다.

**Q: 프록시 서버를 설명하고 사용 사례에 대해 설명해보세요.**

A: 프록시 서버란 서버 앞단에 둬서 캐싱, 로깅, 데이터 분석을 서버보다 먼저 하는 서버를 말합니다. 이를 통해 포트 번호를 바꿔서 사용자가 실제 서버의 포트에 접근하지 못하게 할 수 있으며 공격자의 DDOS 공격을 차단하거나 CDN을 프록시 서버로 달아서 캐싱 처리를 용이하게 할 수 있습니다. nginx로 Node.js로 이루어진 서버의 앞단에 둬서 버퍼 오버플로우를 해결하거나 CloudFlare를 둬서 캐싱, 로그 분석 등을 하는 사용 사례가 있습니다.

**Q: MVC 패턴을 설명하고 MVVM 패턴과의 차이는 무엇인지 설명해보세요.**

A: MVC 패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다. 앱의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다는 점과 재사용성과 확장성이 용이하다는 장점이 있고, 애플리케이션이 복잡해질수록 모델과 뷰의 관계 또한 복잡해지는 단점이 있습니다.

MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴입니다. 여기서 뷰모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징입니다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있습니다.

#### 추가 예상 질문들:
- 싱글톤 패턴의 단점과 이를 해결하는 방법은?
- 팩토리 패턴과 추상 팩토리 패턴의 차이점은?
- 전략 패턴과 상태 패턴의 차이점은?
- 어떤 상황에서 어떤 디자인 패턴을 사용하는 것이 적절한가?

### 프로그래밍 패러다임 관련

#### 추가 예상 질문들:
- 함수형 프로그래밍의 장점과 단점은?
- 순수 함수와 부작용의 개념을 설명해보세요
- 객체지향 프로그래밍의 SOLID 원칙을 실제 프로젝트에 어떻게 적용했나요?
- 절차형과 객체지향 프로그래밍 중 어떤 것을 선택할 것인가요?
- 실제 프로젝트에서 여러 패러다임을 혼합해서 사용한 경험이 있나요?

**이러한 질문들에 대비하여 각 패턴과 패러다임의 개념뿐만 아니라 실제 사용 경험과 구체적인 적용 사례를 준비해두는 것이 중요.**





# Chapter 2: 네트워크 - 면접 대비 요약

## 목차

### Section 1: 네트워크의 기초
1. [처리량과 지연 시간](#1-처리량과-지연-시간)
2. [네트워크 토폴로지와 병목 현상](#2-네트워크-토폴로지와-병목-현상)
3. [네트워크 분류](#3-네트워크-분류)
4. [네트워크 성능 분석 명령어](#4-네트워크-성능-분석-명령어)
5. [네트워크 프로토콜 표준화](#5-네트워크-프로토콜-표준화)

### Section 2: TCP/IP 4계층 모델
1. [계층 구조](#1-계층-구조)
2. [애플리케이션 계층](#2-애플리케이션-계층)
3. [전송 계층](#3-전송-계층)
4. [인터넷 계층](#4-인터넷-계층)
5. [링크 계층](#5-링크-계층)
6. [PDU](#6-pdu)

### Section 3: 네트워크 기기
1. [네트워크 기기의 처리 범위](#1-네트워크-기기의-처리-범위)
2. [애플리케이션 계층 기기 - L7 스위치](#2-애플리케이션-계층-기기---l7-스위치)
3. [인터넷 계층 기기 - 라우터, L3 스위치](#3-인터넷-계층-기기---라우터-l3-스위치)
4. [데이터 링크 계층 기기 - L2 스위치, 브리지](#4-데이터-링크-계층-기기---l2-스위치-브리지)
5. [물리 계층 기기 - NIC, 리피터, AP](#5-물리-계층-기기---nic-리피터-ap)

### Section 4: IP 주소
1. [ARP](#1-arp)
2. [홉바이홉 통신](#2-홉바이홉-통신)
3. [IP 주소 체계](#3-ip-주소-체계)
4. [IP 주소를 이용한 위치 정보](#4-ip-주소를-이용한-위치-정보)

### Section 5: HTTP
1. [HTTP/1.0](#1-http10)
2. [HTTP/1.1](#2-http11)
3. [HTTP/2](#3-http2)
4. [HTTPS](#4-https)
5. [HTTP/3](#5-http3)

---

## Section 1: 네트워크의 기초

### 네트워크 기본 개념
- **네트워크**: 노드(node)와 링크(link)가 서로 연결되어 리소스를 공유하는 집합
- **노드**: 서버, 라우터, 스위치 등 네트워크 장치
- **링크**: 유선 또는 무선 연결

### 1. 처리량과 지연 시간

#### 처리량 (Throughput)
- **정의**: 링크를 통해 전달되는 단위 시간당 데이터양
- **단위**: bps(bits per second)
- **영향 요인**:
 - 트래픽 (사용자 접속량)
 - 네트워크 장치 간 대역폭
 - 네트워크 중간 에러
 - 장치의 하드웨어 스펙

#### 지연 시간 (Latency)
- **정의**: 요청이 처리되는 시간, 메시지가 두 장치 사이를 왕복하는 데 걸리는 시간
- **영향 요인**:
 - 매체 타입 (무선, 유선)
 - 패킷 크기
 - 라우터의 패킷 처리 시간

**면접 출제 포인트**: 네트워크 성능 지표인 처리량과 지연 시간의 차이, 각각에 영향을 미치는 요인들을 정확히 구분해서 설명할 수 있어야 함

### 2. 네트워크 토폴로지와 병목 현상

#### 네트워크 토폴로지
- **정의**: 노드와 링크가 배치되어 있는 연결 형태

##### 주요 토폴로지 유형

1. **트리 토폴로지 (계층형)**
  - 트리 형태의 계층적 구조
  - 장점: 노드 추가/삭제 용이
  - 단점: 특정 노드 트래픽 집중 시 하위 노드 영향

2. **버스 토폴로지**
  - 중앙 통신 회선에 여러 노드 연결
  - 장점: 설치 비용 적음, 신뢰성 우수
  - 단점: 스푸핑 가능

3. **스타 토폴로지 (성형)**
  - 중앙 노드에 모든 노드 연결
  - 장점: 노드 추가/에러 탐지 용이, 패킷 충돌 적음
  - 단점: 중앙 노드 장애 시 전체 네트워크 사용 불가

4. **링형 토폴로지**
  - 각 노드가 양 옆 두 노드와 연결된 고리 구조
  - 장점: 네트워크 손실 적음, 충돌 가능성 적음
  - 단점: 네트워크 구성 변경 어려움, 회선 장애 시 전체 영향

5. **메시 토폴로지 (망형)**
  - 그물망처럼 연결된 구조
  - 장점: 다중 경로 존재로 안정성 높음, 트래픽 분산 가능
  - 단점: 노드 추가 어려움, 구축/운용 비용 고가

#### 병목 현상
- **정의**: 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한받는 현상
- **해결 방법**: 네트워크 토폴로지 분석을 통한 회선 추가, 대역폭 증설 등

**면접 출제 포인트**: 각 토폴로지의 장단점과 적용 사례, 병목 현상 해결 방법을 실제 사례와 함께 설명할 수 있어야 함

### 3. 네트워크 분류

#### 규모별 분류
1. **LAN (Local Area Network)**
  - 근거리 통신망
  - 같은 건물이나 캠퍼스 내 좁은 공간
  - 특징: 전송 속도 빠름, 혼잡하지 않음

2. **MAN (Metropolitan Area Network)**
  - 대도시 지역 네트워크
  - 도시 같은 넓은 지역
  - 특징: 전송 속도 평균, LAN보다 혼잡

3. **WAN (Wide Area Network)**
  - 광역 네트워크
  - 국가 또는 대륙 같은 더 넓은 지역
  - 특징: 전송 속도 낮음, 가장 혼잡

**면접 출제 포인트**: 각 네트워크 분류의 특징과 차이점, 실제 적용 사례를 설명할 수 있어야 함

### 4. 네트워크 성능 분석 명령어

#### 주요 명령어들

1. **ping**
  - 목적: 네트워크 상태 확인
  - 원리: ICMP 프로토콜 사용
  - 기능: 패킷 수신 상태와 도달 시간 측정

2. **netstat**
  - 목적: 네트워크 상태 표시
  - 기능: 네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 리스트 제공
  - 주요 용도: 서비스 포트 열림 상태 확인

3. **nslookup**
  - 목적: DNS 관련 내용 확인
  - 기능: 특정 도메인에 매핑된 IP 확인

4. **tracert/traceroute**
  - 목적: 목적지 노드까지 네트워크 경로 확인
  - 기능: 구간별 응답 시간 측정

#### 기타 도구
- **tcpdump**: 패킷 캡처
- **wireshark/netmon**: 네트워크 분석 프로그램

**면접 출제 포인트**: 각 명령어의 용도와 사용법, 네트워크 문제 상황별 적절한 명령어 선택 능력

### 5. 네트워크 프로토콜 표준화

#### 표준화 기관
- **IEEE**: 전기전자기술자협회
- **IETF**: 인터넷기술작업팀

#### 주요 프로토콜 예시
- **IEEE802.3**: 유선 LAN 프로토콜
- **HTTP**: 웹 서비스를 위한 프로토콜

**면접 출제 포인트**: 프로토콜 표준화의 중요성과 주요 표준화 기관의 역할

---

## Section 2: TCP/IP 4계층 모델

### 1. 계층 구조

#### TCP/IP 4계층 vs OSI 7계층
- **TCP/IP 4계층**: 애플리케이션, 전송, 인터넷, 링크 계층
- **OSI 7계층**: 애플리케이션, 프레젠테이션, 세션, 전송, 네트워크, 데이터 링크, 물리 계층

#### 계층화의 장점
- 특정 계층 변경 시 다른 계층에 영향 없음
- 유연한 설계 가능

**면접 출제 포인트**: TCP/IP 4계층과 OSI 7계층의 차이점, 계층화의 장점을 실제 예시와 함께 설명

### 2. 애플리케이션 계층

#### 주요 프로토콜
- **FTP**: 파일 전송 프로토콜
- **HTTP**: 웹 데이터 통신 프로토콜
- **SSH**: 보안 네트워크 운영 프로토콜
- **SMTP**: 전자메일 전송 프로토콜
- **DNS**: 도메인 이름과 IP 주소 매핑 서비스

**면접 출제 포인트**: 각 프로토콜의 특징과 사용 목적, 포트 번호 등

### 3. 전송 계층

#### TCP (전송 제어 프로토콜)
- **특징**: 연결 지향, 신뢰성 보장, 순서 보장
- **가상회선 패킷 교환 방식**: 패킷이 전송된 순서대로 도착

#### UDP (사용자 데이터그램 프로토콜)  
- **특징**: 비연결 지향, 빠른 전송, 신뢰성 보장 안 함
- **데이터그램 패킷 교환 방식**: 패킷이 독립적으로 이동, 순서가 다를 수 있음

#### TCP 3-way Handshake (연결 성립)
1. **SYN**: 클라이언트가 서버에 연결 요청 (ISN 포함)
2. **SYN + ACK**: 서버가 요청 수락 및 연결 요청 (서버 ISN + 클라이언트 ISN+1)
3. **ACK**: 클라이언트가 연결 확인 (서버 ISN+1)

#### TCP 4-way Handshake (연결 해제)
1. **FIN**: 클라이언트가 연결 해제 요청
2. **ACK**: 서버가 해제 요청 수락
3. **FIN**: 서버가 연결 해제 요청  
4. **ACK**: 클라이언트가 해제 확인

#### TIME_WAIT의 필요성
- 지연 패킷 처리를 위함
- 연결이 완전히 종료되었는지 확인하기 위함

**면접 출제 포인트**: TCP와 UDP의 차이점, TCP 연결/해제 과정, TIME_WAIT 상태의 의미와 필요성

### 4. 인터넷 계층

#### 주요 프로토콜
- **IP**: 패킷을 목적지로 전송
- **ARP**: IP 주소를 MAC 주소로 변환
- **ICMP**: 오류 보고 및 네트워크 진단

#### 특징
- 비연결형적 특징
- 상대방이 제대로 받았는지 보장하지 않음

**면접 출제 포인트**: 인터넷 계층의 역할과 주요 프로토콜들의 기능

### 5. 링크 계층

#### 유선 LAN (IEEE802.3)
- **이더넷**: 전이중화 통신 사용
- **케이블 종류**:
 - 트위스트 페어 케이블 (UTP/STP)
 - 광섬유 케이블

#### 무선 LAN (IEEE802.11)
- **특징**: 반이중화 통신 사용
- **CSMA/CA**: 충돌 방지 방식
- **주파수**: 2.4GHz, 5GHz 대역

#### 네트워크 구성
- **BSS (Basic Service Set)**: 하나의 AP 기반 구성
- **ESS (Extended Service Set)**: 여러 BSS 연결, 이동성 지원

**면접 출제 포인트**: 유선과 무선 LAN의 차이점, CSMA/CD와 CSMA/CA의 차이, BSS와 ESS의 개념

### 6. PDU

#### 계층별 데이터 단위
- **애플리케이션 계층**: 메시지
- **전송 계층**: 세그먼트 (TCP), 데이터그램 (UDP)
- **인터넷 계층**: 패킷
- **링크 계층**: 프레임

#### 캡슐화/비캡슐화 과정
- **캡슐화**: 상위 계층 데이터에 하위 계층 헤더 추가
- **비캡슐화**: 하위 계층에서 상위 계층으로 헤더 제거

**면접 출제 포인트**: 각 계층의 PDU 명칭과 데이터 전송 과정에서의 캡슐화/비캡슐화 과정

---

## Section 3: 네트워크 기기

### 1. 네트워크 기기의 처리 범위

#### 계층별 처리 기기
- **애플리케이션 계층**: L7 스위치
- **인터넷 계층**: 라우터, L3 스위치
- **데이터 링크 계층**: L2 스위치, 브리지
- **물리 계층**: NIC, 리피터, AP

#### 처리 범위 원칙
- 상위 계층 기기는 하위 계층 처리 가능
- 하위 계층 기기는 상위 계층 처리 불가능

### 2. 애플리케이션 계층 기기 - L7 스위치

#### L7 스위치 (로드밸런서)
- **기능**: 서버 부하 분산
- **분산 기준**: URL, 서버, 캐시, 쿠키 등
- **추가 기능**: 필터링, 트래픽 모니터링

#### L4 vs L7 스위치 차이
- **L4 스위치**: IP와 포트 기반 분산
- **L7 스위치**: URL, HTTP 헤더, 쿠키 등 기반 분산

#### 헬스 체크
- **목적**: 정상/비정상 서버 판별
- **방법**: TCP, HTTP 등을 통한 주기적 요청

#### 서버 이중화
- 가상 IP 제공으로 안정적인 서비스 운영
- 서버 장애 시에도 서비스 지속성 보장

**면접 출제 포인트**: 로드밸런서의 동작 원리와 종류, 헬스 체크 방식, 서버 이중화의 중요성

### 3. 인터넷 계층 기기 - 라우터, L3 스위치

#### 라우터
- **기능**: 네트워크 연결/분할/구분
- **라우팅**: 최적 경로로 패킷 포워딩

#### L3 스위치
- **정의**: L2 스위치 기능 + 라우팅 기능
- **차이점**: 하드웨어 기반 라우팅 (라우터는 소프트웨어 기반도 포함)

### 4. 데이터 링크 계층 기기 - L2 스위치, 브리지

#### L2 스위치
- **기능**: MAC 주소 테이블 관리, 패킷 전송
- **특징**: IP 주소 이해 불가, MAC 주소 기반 스위칭

#### 브리지
- **기능**: 두 LAN 상호 접속
- **용도**: 통신망 범위 확장

### 5. 물리 계층 기기 - NIC, 리피터, AP

#### NIC (네트워크 인터페이스 카드)
- **기능**: 네트워크 데이터 송수신
- **특징**: 고유 MAC 주소 보유

#### AP (Access Point)
- **기능**: 유선 LAN을 무선 LAN으로 변환
- **특징**: 패킷 복사 기능

**면접 출제 포인트**: 각 계층별 네트워크 기기의 역할과 특징, 실제 네트워크 구성에서의 활용

---

## Section 4: IP 주소

### 1. ARP

#### ARP (주소 해석 프로토콜)
- **기능**: IP 주소를 MAC 주소로 변환
- **과정**: 
 1. ARP Request 브로드캐스트
 2. 해당 IP를 가진 장치가 ARP Reply 유니캐스트로 MAC 주소 응답

#### RARP
- **기능**: MAC 주소를 IP 주소로 변환

**면접 출제 포인트**: ARP의 동작 과정과 네트워크 통신에서의 역할

### 2. 홉바이홉 통신

#### 홉바이홉 통신 과정
- 라우팅 테이블의 IP를 기반으로 패킷 전달
- 여러 라우터를 거쳐 최종 목적지 도달

#### 라우팅 테이블
- **구성**: 목적지 정보와 다음 라우터 정보
- **게이트웨이**: 서로 다른 네트워크 간 통신을 가능하게 하는 관문

**면접 출제 포인트**: 패킷이 목적지까지 전달되는 과정, 라우팅의 개념

### 3. IP 주소 체계

#### IPv4 vs IPv6
- **IPv4**: 32비트, 8비트 단위로 표기
- **IPv6**: 64비트, 16비트 단위로 표기

#### 클래스 기반 할당 방식
- **클래스 A, B, C**: 일대일 통신
- **클래스 D**: 멀티캐스트
- **클래스 E**: 예비용

#### IP 주소 부족 해결 방안
1. **DHCP**: IP 주소 자동 할당
2. **NAT**: 공인 IP와 사설 IP 분리
3. **IPv6**: 주소 공간 확장

#### NAT (네트워크 주소 변환)
- **기능**: 사설 IP를 공인 IP로 변환
- **장점**: IP 주소 절약, 보안 향상
- **단점**: 접속 속도 저하 가능성

**면접 출제 포인트**: IPv4와 IPv6의 차이, NAT의 동작 원리와 필요성, IP 주소 부족 문제 해결 방안

### 4. IP 주소를 이용한 위치 정보

- IP 주소를 통해 동/구 단위까지 위치 추적 가능
- 실제 지리적 위치와의 연관성

---

## Section 5: HTTP

### 1. HTTP/1.0

#### 특징
- 한 연결당 하나의 요청 처리
- **RTT 증가 문제**: 매번 TCP 3-way handshake 필요

#### RTT 증가 해결 방법
1. **이미지 스플리팅**: 여러 이미지를 하나로 합쳐서 전송
2. **코드 압축**: 개행 문자, 빈칸 제거로 크기 최소화
3. **이미지 Base64 인코딩**: 이미지를 문자열로 변환

**면접 출제 포인트**: HTTP/1.0의 문제점과 해결 방안

### 2. HTTP/1.1

#### 개선사항
- **Keep-alive**: 한 번 TCP 연결 후 여러 파일 송수신 가능
- 표준화된 지속 연결

#### 여전한 문제점
1. **HOL Blocking**: 첫 번째 패킷 지연 시 뒤 패킷들도 대기
2. **무거운 헤더 구조**: 압축되지 않은 메타데이터

**면접 출제 포인트**: HTTP/1.0과 1.1의 차이점, HOL Blocking 문제

### 3. HTTP/2

#### 주요 개선사항

1. **멀티플렉싱**
  - 여러 스트림을 통한 병렬 송수신
  - 하나의 스트림 문제가 다른 스트림에 영향 없음

2. **헤더 압축**
  - HPACK 압축 형식 사용
  - 허프만 코딩 알고리즘 활용

3. **서버 푸시**
  - 클라이언트 요청 없이 서버가 리소스 전송
  - HTML 읽으면서 CSS/JS 파일 미리 전송

**면접 출제 포인트**: HTTP/2의 핵심 기능들과 성능 개선 효과, 멀티플렉싱의 동작 원리

### 4. HTTPS

#### SSL/TLS
- **목적**: 통신 암호화로 보안 강화
- **위치**: 애플리케이션 계층과 전송 계층 사이
- **발전**: SSL 1.0 → TLS 1.3

#### TLS Handshake 과정
1. **사이퍼 슈트 교환**: 암호화 알고리즘 협상
2. **인증서 검증**: CA 발급 인증서로 서버 신뢰성 확인
3. **키 교환**: 디피-헬만 키 교환으로 대칭키 생성

#### 보안 세션 구성 요소
- **인증 메커니즘**: CA 인증서 기반
- **키 교환 암호화**: ECDHE, DHE 등
- **해싱 알고리즘**: SHA-256, SHA-384 등

#### HTTPS 구축 방법
1. 직접 CA에서 인증서 구매
2. 로드밸런서에서 HTTPS 제공
3. CDN에서 HTTPS 제공

#### SEO 이점
- 구글이 HTTPS 사이트를 검색 순위에서 우대
- 보안 강화와 검색 최적화 동시 달성

**면접 출제 포인트**: HTTPS와 HTTP의 차이점, TLS handshake 과정, 인증서의 역할, 디피-헬만 키 교환 알고리즘

### 5. HTTP/3

#### 주요 특징
- **QUIC 프로토콜 기반**: UDP 위에서 동작
- **멀티플렉싱 지원**: HTTP/2의 장점 유지
- **초기 연결 지연 시간 감소**: 1-RTT 연결

#### 성능 향상
- TCP 3-way handshake 불필요
- 순방향 오류 수정 메커니즘 (FEC) 적용
- 패킷 손실률 감소

**면접 출제 포인트**: HTTP/3와 이전 버전들의 차이점, QUIC 프로토콜의 특징과 장점

---

## 예상 면접 질문

### 네트워크 기초

**Q: OSI 7계층과 TCP/IP 4계층의 차이점은 무엇인가요?**

A: TCP/IP 계층과 달리 OSI 계층은 애플리케이션 계층을 세 개로 쪼개고 링크 계층을 데이터 링크 계층, 물리 계층으로 나눠서 설명하는 것이 다르며, 인터넷 계층을 네트워크 계층으로 부른다는 점이 다릅니다.

**Q: TCP와 UDP의 차이점을 설명해주세요.**

A: TCP는 연결 지향 프로토콜로 3-way handshake를 통해 연결을 설정하고, 데이터 전송 순서를 보장하며 신뢰성을 제공합니다. 반면 UDP는 비연결 지향 프로토콜로 빠른 전송이 가능하지만 순서나 신뢰성을 보장하지 않습니다. TCP는 웹 브라우징, 이메일 등에 사용되고, UDP는 실시간 스트리밍, 게임 등에 사용됩니다.

**Q: HTTP/2를 설명하고 장점을 설명하세요.**

A: HTTP/2는 HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜입니다.

